---
import {
  Upload,
  FileText,
  Download,
  Trash2,
  Settings,
  AlertTriangle,
  CheckCircle,
  Loader2,
  Minimize2,
} from "lucide-react";

interface Props {
  labels?: {
    uploadTitle?: string;
    uploadDesc?: string;
    dropTitle?: string;
    processing?: string;
    download?: string;
    downloadAll?: string;
    settings?: string;
    quality?: string;
    grayscale?: string;
    grayscaleDesc?: string;
    warningTitle?: string;
    warningDesc?: string;
    qualityScreen?: string;
    qualityEbook?: string;
    qualityPrinter?: string;
    statusOptimizing?: string;
    statusProcessingPage?: string;
    statusError?: string;
    zipping?: string;
    footer?: string;
  };
}

const {
  labels = {
    uploadTitle: "Compress PDF Files",
    uploadDesc: "Drag & drop PDF files here, or click to select",
    dropTitle: "Drop to Add",
    processing: "Processing...",
    download: "Download",
    downloadAll: "Download All ZIP",
    settings: "Compression Settings",
    quality: "Compression Level",
    grayscale: "Grayscale (B&W)",
    grayscaleDesc: "Converts to black & white for maximum reduction",
    warningTitle: "Visual Compression Mode",
    warningDesc:
      "This tool optimizes PDFs by converting pages to compressed images. Text will no longer be selectable/searchable.",
    qualityScreen: "Smallest size, low res (72 dpi)",
    qualityEbook: "Best balance of size & quality (150 dpi)",
    qualityPrinter: "High quality for printing (300 dpi)",
    statusOptimizing: "Optimizing PDF structure... This may take a moment.",
    statusProcessingPage: "Processing page {current} of {total}...",
    statusError: "Error processing file. Engine may not be loaded.",
    zipping: "Zipping...",
    footer: "Powered by Ghostscript. This tool is for educational/personal use (AGPL License).",
  },
} = Astro.props;
---

<div 
  class="w-full max-w-4xl mx-auto space-y-8"
  id="pdf-compressor-app"
  data-labels={JSON.stringify(labels)}
>
  <!-- Warning Banner -->
  <div
    class="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700/50 rounded-xl p-4 flex gap-3 items-start animate-fade-up"
  >
    <AlertTriangle
      className="w-5 h-5 text-amber-600 dark:text-amber-500 flex-shrink-0 mt-0.5"
    />
    <div>
      <h3 class="font-bold text-amber-800 dark:text-amber-400 text-sm mb-1">
        {labels.warningTitle}
      </h3>
      <p
        class="text-sm text-amber-700 dark:text-amber-300/80 leading-relaxed max-w-2xl"
      >
        {labels.warningDesc}
      </p>
    </div>
  </div>

  <div
    class="grid grid-cols-1 lg:grid-cols-3 gap-6 animate-fade-up [animation-delay:100ms]"
  >
    <!-- Left Column: Upload -->
    <div class="lg:col-span-1 space-y-6">
      <!-- Upload Zone -->
      <div
        id="pdf-drop-zone"
        class="border-2 border-dashed border-slate-300 dark:border-slate-700 rounded-xl bg-slate-50/50 dark:bg-slate-900/50 p-8 flex flex-col items-center justify-center text-center cursor-pointer hover:border-amber-400 dark:hover:border-amber-500 hover:bg-slate-50 dark:hover:bg-slate-800 transition-all duration-300 group sticky top-6"
      >
        <div
          class="p-4 rounded-full bg-white dark:bg-slate-800 group-hover:bg-amber-50 dark:group-hover:bg-amber-900/20 group-hover:scale-110 transition-all duration-300 shadow-sm mb-3"
        >
          <Upload
            className="w-8 h-8 text-slate-400 group-hover:text-amber-500"
          />
        </div>
        <input
          type="file"
          id="pdf-input"
          accept="application/pdf"
          multiple
          class="hidden"
        />
        <h3
          class="font-bold text-slate-700 dark:text-slate-200 mb-1 group-hover:text-amber-600 dark:group-hover:text-amber-400 transition-colors"
        >
          {labels.uploadTitle}
        </h3>
        <p class="text-xs text-slate-500 dark:text-slate-400">
          {labels.uploadDesc}
        </p>
      </div>
    </div>

    <!-- Right Column: List -->
    <div class="lg:col-span-2">
      <div id="file-list" class="space-y-4 min-h-[400px]">
        <!-- Empty State -->
        <div
          id="empty-state"
          class="h-full flex flex-col items-center justify-center text-center p-10 border-2 border-dashed border-slate-100 dark:border-slate-800 rounded-2xl"
        >
          <Minimize2
            className="w-16 h-16 text-slate-200 dark:text-slate-800 mb-4"
          />
          <p class="text-slate-400 font-medium">No files in queue</p>
        </div>
      </div>

      <!-- Action Bar (Appears when files exist) -->
      <div
        id="action-bar"
        class="hidden mt-6 pt-6 border-t border-slate-200 dark:border-slate-800 flex justify-end"
      >
        <button
          id="download-all-btn"
          class="flex items-center gap-2 px-6 py-3 rounded-xl bg-slate-900 dark:bg-white text-white dark:text-slate-900 font-bold hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <Download className="w-4 h-4" />
          {labels.downloadAll}
        </button>
      </div>
    </div>
  </div>
</div>

<template id="file-item-template">
  <div
    class="file-item relative bg-white dark:bg-slate-900 rounded-xl border border-slate-200 dark:border-slate-800 p-4 shadow-sm hover:shadow-md transition-all cursor-pointer group/card"
  >
    <div class="flex items-start gap-4 pointer-events-none">
      <!-- Icon -->
      <div
        class="p-3 rounded-lg bg-red-50 dark:bg-red-900/20 text-red-500 dark:text-red-400"
      >
        <FileText className="w-6 h-6" />
      </div>

      <!-- Content -->
      <div class="flex-1 min-w-0 pointer-events-auto">
        <div class="flex items-start justify-between mb-2">
          <div>
            <h4
              class="font-bold text-slate-700 dark:text-slate-200 truncate pr-4 text-sm filename"
            >
              filename.pdf
            </h4>
            <div
              class="flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400 mt-0.5"
            >
              <span class="original-size">2.4 MB</span>
              <span class="arrow hidden">â†’</span>
              <span
                class="new-size hidden font-mono text-slate-900 dark:text-slate-200 font-bold"
                >1.1 MB</span
              >
            </div>
          </div>
          <div class="flex items-center gap-1">
             <button
              class="text-slate-400 hover:text-amber-500 transition-colors settings-btn p-1 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-800"
              title="Compression Settings"
            >
              <Settings className="w-4 h-4" />
            </button>
            <button
              class="text-slate-400 hover:text-red-500 transition-colors remove-btn p-1 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-800"
              title="Remove File"
            >
              <Trash2 className="w-4 h-4" />
            </button>
          </div>
        </div>

        <!-- Settings Panel (Visible by default) -->
        <div class="settings-panel mb-3 p-3 bg-slate-50 dark:bg-slate-800/50 rounded-lg border border-slate-100 dark:border-slate-800" onclick="event.stopPropagation()">
             <div class="flex flex-col gap-3">
                <div class="space-y-2">
                    <label class="text-[10px] font-bold uppercase tracking-wider text-slate-500 dark:text-slate-400">Quality Profile</label>
                    <div class="flex gap-2">
                        <label class="flex-1 cursor-pointer">
                            <input type="radio" name="quality" value="screen" class="peer sr-only">
                            <div class="text-center py-1.5 px-2 rounded-lg border border-slate-200 dark:border-slate-700 text-xs font-medium text-slate-600 dark:text-slate-300 peer-checked:bg-amber-500 peer-checked:text-white peer-checked:border-amber-500 transition-all">Screen</div>
                        </label>
                        <label class="flex-1 cursor-pointer">
                            <input type="radio" name="quality" value="ebook" class="peer sr-only" checked>
                            <div class="text-center py-1.5 px-2 rounded-lg border border-slate-200 dark:border-slate-700 text-xs font-medium text-slate-600 dark:text-slate-300 peer-checked:bg-amber-500 peer-checked:text-white peer-checked:border-amber-500 transition-all">eBook</div>
                        </label>
                         <label class="flex-1 cursor-pointer">
                            <input type="radio" name="quality" value="printer" class="peer sr-only">
                            <div class="text-center py-1.5 px-2 rounded-lg border border-slate-200 dark:border-slate-700 text-xs font-medium text-slate-600 dark:text-slate-300 peer-checked:bg-amber-500 peer-checked:text-white peer-checked:border-amber-500 transition-all">Printer</div>
                        </label>
                    </div>
                    <p class="text-[10px] text-slate-400 text-center quality-desc">{labels.qualityEbook}</p>
                </div>
             </div>
        </div>

        <!-- Progress Bar -->
        <div class="progress-section mt-3">
          <div class="flex justify-between text-xs mb-1.5">
            <span
              class="status-text font-medium text-amber-600 dark:text-amber-400"
              >Waiting...</span
            >
            <span class="percentage text-slate-500"></span>
          </div>
          <div
            class="h-2 w-full bg-slate-100 dark:bg-slate-800 rounded-full overflow-hidden"
          >
            <div
              class="progress-bar h-full bg-amber-500 transition-all duration-300 w-0"
            >
            </div>
          </div>
        </div>

        <!-- Success Actions -->
        <div class="success-actions hidden mt-3 flex items-center gap-3" onclick="event.stopPropagation()">
          <button
            class="download-btn flex-1 flex items-center justify-center gap-2 px-4 py-2 bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400 rounded-lg text-xs font-bold hover:bg-amber-200 dark:hover:bg-amber-900/50 transition-colors"
          >
            <Download className="w-3.5 h-3.5" />
            {labels.download}
          </button>
          <div
            class="px-3 py-2 rounded-lg bg-green-50 dark:bg-green-900/20 text-green-600 dark:text-green-400 text-xs font-bold savings-badge"
          >
            -45%
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<div class="text-center mt-8 text-[10px] text-slate-400">
  {labels.footer}
</div>

<script>
  import JSZip from "jszip";
  import * as pdfjsLib from "pdfjs-dist";

  // Set worker source for pdf.js (needed for getDocument)
  // Set worker source for pdf.js (needed for getDocument)
  pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdfjs/pdf.worker.min.mjs';

  // State
  interface FileQueueItem {
    id: string;
    file: File;
    status: "pending" | "processing" | "done" | "error";
    originalSize: number;
    compressedSize?: number;
    blob?: Blob;
    element: HTMLElement;
    quality: 'screen' | 'ebook' | 'printer';
    totalPages?: number;
    currentProgress: number;
    progressInterval?: number;
  }

  const queue: FileQueueItem[] = [];
  const MAX_CONCURRENT = 1;
  let processingCount = 0;

  // DOM
  const dropZone = document.getElementById("pdf-drop-zone");
  const fileInput = document.getElementById("pdf-input") as HTMLInputElement;
  const fileList = document.getElementById("file-list");
  const emptyState = document.getElementById("empty-state");
  const template = document.getElementById(
    "file-item-template",
  ) as HTMLTemplateElement;
  const downloadAllBtn = document.getElementById(
    "download-all-btn",
  ) as HTMLButtonElement;
  const actionBar = document.getElementById("action-bar");
  
  // Get Labels
  const appContainer = document.getElementById('pdf-compressor-app');
  const labels = JSON.parse(appContainer?.dataset.labels || '{}');

  // --- Upload Logic ---
  dropZone?.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", (e) =>
    handleFiles((e.target as HTMLInputElement).files),
  );

  dropZone?.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropZone.classList.add("border-amber-500", "bg-amber-50/50");
  });

  dropZone?.addEventListener("dragleave", () => {
    dropZone.classList.remove("border-amber-500", "bg-amber-50/50");
  });

  dropZone?.addEventListener("drop", (e) => {
    e.preventDefault();
    dropZone.classList.remove("border-amber-500", "bg-amber-50/50");
    if (e.dataTransfer?.files) handleFiles(e.dataTransfer.files);
  });

  function handleFiles(files: FileList | null) {
    if (!files) return;

    emptyState?.classList.add("hidden");
    actionBar?.classList.remove("hidden");

    Array.from(files).forEach((file) => {
      if (file.type !== "application/pdf") return;

      const id = Math.random().toString(36).substr(2, 9);
      const itemElement = createQueueElement(file, id, 'ebook'); // Default to ebook
      fileList?.appendChild(itemElement);

      const item: FileQueueItem = {
        id,
        file,
        status: "pending",
        originalSize: file.size,
        element: itemElement,
        element: itemElement,
        quality: 'ebook',
        currentProgress: 0
      };

      queue.push(item);
      processQueue();
    });

    // Reset input
    fileInput.value = "";
  }

  function createQueueElement(file: File, id: string, quality: string): HTMLElement {
    const clone = template.content.cloneNode(true) as DocumentFragment;
    const el = clone.querySelector(".file-item") as HTMLElement;
    el.dataset.id = id;

    // Set Info
    el.querySelector(".filename")!.textContent = file.name;
    el.querySelector(".original-size")!.textContent = formatBytes(file.size);

    // Settings UI Logic
    const settingsBtn = el.querySelector('.settings-btn') as HTMLButtonElement;
    const settingsPanel = el.querySelector('.settings-panel') as HTMLElement;
    const qualityInputs = el.querySelectorAll('input[name="quality"]');
    const qualityDesc = el.querySelector('.quality-desc') as HTMLElement;

    // Toggle Panel Function
    const togglePanel = () => {
        settingsPanel.classList.toggle('hidden');
        settingsBtn.classList.toggle('text-amber-500');
    };

    // Card Click
    el.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        if (target.closest('button') || target.closest('input') || target.closest('label')) return;
        togglePanel();
    });

    // Button Click
    settingsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        togglePanel();
    });

    // Update Settings State & Re-compress
    const updateAndRecompress = () => {
        const item = queue.find(i => i.id === id);
        if (!item) return;

        if (item.status === 'done' || item.status === 'error') {
            item.status = 'pending';
            const progressSection = el.querySelector(".progress-section") as HTMLElement;
            const successActions = el.querySelector(".success-actions") as HTMLElement;
            
            progressSection.classList.remove("hidden");
            successActions.classList.add("hidden");
            successActions.classList.remove("flex");
            
            processQueue();
        }
    };

    qualityInputs.forEach(input => {
        input.addEventListener('change', (e) => {
            const target = e.target as HTMLInputElement;
            if (target.checked) {
                const val = target.value;
                const item = queue.find(i => i.id === id);
                if (item) {
                    item.quality = val as any;
                    
                    // Update description
                    if (val === 'screen') qualityDesc.textContent = labels.qualityScreen;
                    if (val === 'ebook') qualityDesc.textContent = labels.qualityEbook;
                    if (val === 'printer') qualityDesc.textContent = labels.qualityPrinter;

                    updateAndRecompress();
                }
            }
        });
        (input as HTMLInputElement).name = `quality-${id}`;
    });

    // Events
    el.querySelector(".remove-btn")!.addEventListener("click", (e) => {
        e.stopPropagation();
        removeItem(id);
    });

    return el;
  }

  async function processQueue() {
    if (processingCount >= MAX_CONCURRENT) return;

    const nextItem = queue.find((i) => i.status === "pending");
    if (!nextItem) return;

    processingCount++;
    nextItem.status = "processing";
    updateItemUI(nextItem);

    // Disable settings
    const settingsPanel = nextItem.element.querySelector('.settings-panel');
    if (settingsPanel) {
        const inputs = settingsPanel.querySelectorAll('input');
        inputs.forEach(i => i.disabled = true);
        settingsPanel.classList.add('opacity-50', 'pointer-events-none');
    }

    try {
        const arrayBuffer = await nextItem.file.arrayBuffer();
        
        // Get Page Count using pdf.js
        try {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer.slice(0) }).promise;
            nextItem.totalPages = pdf.numPages;
        } catch (err) {
            console.warn("Could not get page count:", err);
            nextItem.totalPages = 0;
        }

        // Start Fake Progress
        nextItem.currentProgress = 0;
        nextItem.progressInterval = window.setInterval(() => {
            if (nextItem.currentProgress < 99) {
                // Faster initial progress
                let increment = 1;
                if (nextItem.currentProgress < 70) {
                    increment = 2; // Very fast start
                } else if (nextItem.currentProgress < 90) {
                    increment = 0.5; // Slow down a bit
                } else {
                    increment = 0.1; // Crawl at the end
                }
                
                nextItem.currentProgress = Math.min(99, nextItem.currentProgress + increment);
                
                const progressBar = nextItem.element.querySelector(".progress-bar") as HTMLElement;
                const percentage = nextItem.element.querySelector(".percentage") as HTMLElement;
                
                progressBar.style.width = `${nextItem.currentProgress}%`;
                percentage.textContent = `${Math.round(nextItem.currentProgress)}%`;
            }
        }, 100); // Update every 100ms (faster updates)

        // Spawn One-Shot Worker
        const worker = new Worker('/workers/ghostscriptWorker.js');
        
        worker.onmessage = (e) => {
            const { id, type, success, blob, error, current } = e.data;
            if (id !== nextItem.id) return;

            if (type === 'progress') {
                const total = nextItem.totalPages || 0;
                if (total > 0) {
                    const realPercent = Math.round((current / total) * 100);
                    // Always take the higher value (fake vs real)
                    nextItem.currentProgress = Math.max(nextItem.currentProgress, realPercent);
                    
                    const progressBar = nextItem.element.querySelector(".progress-bar") as HTMLElement;
                    const percentage = nextItem.element.querySelector(".percentage") as HTMLElement;
                    const statusText = nextItem.element.querySelector(".status-text") as HTMLElement;
                    
                    progressBar.classList.remove("animate-pulse");
                    progressBar.style.width = `${nextItem.currentProgress}%`;
                    percentage.textContent = `${Math.round(nextItem.currentProgress)}%`;
                    statusText.textContent = labels.statusProcessingPage
                        .replace('{current}', current.toString())
                        .replace('{total}', total.toString());
                } else {
                    // Fallback if we failed to get page count
                    const statusText = nextItem.element.querySelector(".status-text") as HTMLElement;
                    statusText.textContent = labels.statusProcessingPage
                        .replace('{current}', current.toString())
                        .replace(' of {total}', '');
                }
                return;
            }

            // Clear interval
            if (nextItem.progressInterval) clearInterval(nextItem.progressInterval);

            if (success && blob) {
                nextItem.blob = blob;
                nextItem.compressedSize = blob.size;
                nextItem.status = "done";
            } else {
                console.error('Compression failed:', error);
                nextItem.status = "error";
            }
            
            worker.terminate(); // Cleanup
            processingCount--;
            updateItemUI(nextItem);
            processQueue();
        };

        worker.onerror = (err) => {
            console.error('Worker error:', err);
            if (nextItem.progressInterval) clearInterval(nextItem.progressInterval);
            nextItem.status = "error";
            worker.terminate();
            processingCount--;
            updateItemUI(nextItem);
            processQueue();
        };

        // Send to worker
        worker.postMessage({
            id: nextItem.id,
            fileArrayBuffer: arrayBuffer,
            quality: nextItem.quality
        }, [arrayBuffer]);

    } catch (e) {
      console.error(e);
      if (nextItem.progressInterval) clearInterval(nextItem.progressInterval);
      nextItem.status = "error";
      processingCount--;
      updateItemUI(nextItem);
      processQueue();
    }
  }

  function updateItemUI(item: FileQueueItem) {
    const el = item.element;
    const progressSection = el.querySelector(
      ".progress-section",
    ) as HTMLElement;
    const successActions = el.querySelector(".success-actions") as HTMLElement;
    const arrow = el.querySelector(".arrow") as HTMLElement;
    const newSize = el.querySelector(".new-size") as HTMLElement;
    const settingsPanel = el.querySelector('.settings-panel') as HTMLElement;
    const statusText = el.querySelector(".status-text") as HTMLElement;
    const progressBar = el.querySelector(".progress-bar") as HTMLElement;

    if (item.status === "processing") {
        statusText.textContent = labels.statusOptimizing;
        progressBar.classList.add("animate-pulse");
        progressBar.style.width = "0%"; // Start at 0
    } else if (item.status === "done" && item.blob) {
      progressSection.classList.add("hidden");
      successActions.classList.remove("hidden");
      successActions.classList.add("flex");
      
      // Re-enable settings
      if (settingsPanel) {
        const inputs = settingsPanel.querySelectorAll('input');
        inputs.forEach(i => i.disabled = false);
        settingsPanel.classList.remove('opacity-50', 'pointer-events-none');
      }

      // Update Sizes
      arrow.classList.remove("hidden");
      newSize.classList.remove("hidden");
      newSize.textContent = formatBytes(item.compressedSize!);

      // Savings Badge
      const savedBytes = item.originalSize - item.compressedSize!;
      const savedPercent = Math.round((savedBytes / item.originalSize) * 100);
      const savingsBadge = el.querySelector(".savings-badge") as HTMLElement;

      if (savedBytes > 0) {
        savingsBadge.textContent = `-${savedPercent}%`;
        savingsBadge.classList.add(
          "bg-green-50",
          "text-green-600",
          "dark:bg-green-900/20",
          "dark:text-green-400",
        );
        savingsBadge.classList.remove("bg-red-50", "text-red-600", "dark:bg-red-900/20", "dark:text-red-400");
      } else {
        savingsBadge.textContent = `+${Math.abs(savedPercent)}%`;
        savingsBadge.classList.add(
          "bg-red-50",
          "text-red-600",
          "dark:bg-red-900/20",
          "dark:text-red-400",
        );
        savingsBadge.classList.remove("bg-green-50", "text-green-600", "dark:bg-green-900/20", "dark:text-green-400");
      }

      // Setup Download
      const downloadBtn = el.querySelector(
        ".download-btn",
      ) as HTMLButtonElement;
      downloadBtn.onclick = (e) => {
        e.stopPropagation();
        const url = URL.createObjectURL(item.blob!);
        const a = document.createElement("a");
        const nameParts = item.file.name.split(".");
        nameParts.pop(); // remove extension
        a.href = url;
        a.download = `${nameParts.join(".")}-compressed.pdf`;
        a.click();
      };
    } else if (item.status === "error") {
      statusText.textContent = labels.statusError;
      progressBar.classList.remove("animate-pulse");
      progressBar.classList.add("bg-red-500");
       // Re-enable settings even on error to allow retry
      if (settingsPanel) {
        const inputs = settingsPanel.querySelectorAll('input');
        inputs.forEach(i => i.disabled = false);
        settingsPanel.classList.remove('opacity-50', 'pointer-events-none');
      }
    }
  }

  function formatBytes(bytes: number) {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  function removeItem(id: string) {
    const idx = queue.findIndex((i) => i.id === id);
    if (idx === -1) return;

    queue[idx].element.remove();
    queue.splice(idx, 1);

    if (queue.length === 0) {
      emptyState?.classList.remove("hidden");
      actionBar?.classList.add("hidden");
    }
  }


  // --- Download All ---
  downloadAllBtn.addEventListener("click", async () => {
    const doneItems = queue.filter((i) => i.status === "done" && i.blob);
    if (doneItems.length === 0) return;

    downloadAllBtn.disabled = true;
    downloadAllBtn.textContent = labels.zipping;

    const zip = new JSZip();
    doneItems.forEach((item) => {
      const nameParts = item.file.name.split(".");
      nameParts.pop();
      zip.file(`${nameParts.join(".")}-compressed.pdf`, item.blob!);
    });

    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);
    const a = document.createElement("a");
    a.href = url;
    a.download = "compressed-pdfs.zip";
    a.click();

    downloadAllBtn.disabled = false;
    downloadAllBtn.textContent = labels.downloadAll;
  });
</script>
